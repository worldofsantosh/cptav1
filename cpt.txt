1.
/*
 * RandomServer.java
 * Name of the class: SWEN.601.01 - Software Construction
 * Name: Atharva Vaidya
 * Email: aav6986@g.rit.edu
 * ---------------------------------------------  Final Exam ---------------------------------------------
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Random;

/**
 * The RandomServer class implements a simple server that listens for client requests
 * and responds according to a predefined protocol:
 * - "roll #" where # is a positive integer: roll the specified number of 6-sided dice and return the sum.
 * - "flip": flip a coin and return "heads" or "tails".
 * - "goodbye": respond with "bye" and disconnect.
 * - any other request: respond with "error" and disconnect.
 *
 * This server handles a single client connection at a time (sequential).
 */
public class RandomServer {
    private static final int PORT = 12345;
    private final Random random = new Random();

    /**
     * Starts the RandomServer and listens for a single client connection. Once connected,
     * it handles client requests sequentially until a disconnect condition occurs.
     *
     * @throws IOException if an I/O error occurs when waiting for a connection or reading/writing data
     */
    public void start() throws IOException {
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("RandomServer started. Waiting for client...");
            try (Socket clientSocket = serverSocket.accept();
                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {
                System.out.println("Client connected.");

                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    String response = processRequest(inputLine);
                    out.println(response);
                    if (response.equals("bye") || response.equals("error")) {
                        System.out.println("Client disconnected.");
                        break;
                    }
                }
            }
        }
    }

    /**
     * Processes a single client request according to the defined protocol.
     *
     * @param request the client request string
     * @return the server response string
     */
    private String processRequest(String request) {
        // Check for "goodbye"
        if ("goodbye".equalsIgnoreCase(request.trim())) {
            return "bye";
        }

        // Check for "flip"
        if ("flip".equalsIgnoreCase(request.trim())) {
            return random.nextBoolean() ? "heads" : "tails";
        }

        // Check for "roll #"
        if (request.toLowerCase().startsWith("roll")) {
            String[] parts = request.trim().split("\\s+");
            if (parts.length == 2) {
                try {
                    int numberOfDice = Integer.parseInt(parts[1]);
                    if (numberOfDice > 0) {
                        int sum = 0;
                        for (int i = 0; i < numberOfDice; i++) {
                            sum += (random.nextInt(6) + 1);
                        }
                        return String.valueOf(sum);
                    }
                } catch (NumberFormatException e) {
                    // fall through to error
                }
            }
        }

        // Any other request is invalid
        return "error";
    }

    /**
     * The main method to start the server.
     *
     * @param args command-line arguments
     * @throws IOException if an error occurs starting the server
     */
    public static void main(String[] args) throws IOException {
        RandomServer server = new RandomServer();
        server.start();
    }
}

2.
/*
 * RandomThreadedServer.java
 * Name of the class: SWEN.601.01 - Software Construction
 * Name: Atharva Vaidya
 * Email: aav6986@g.rit.edu
 * ---------------------------------------------  Final Exam ---------------------------------------------
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Random;

/**
 * The RandomThreadedServer class is a multi-threaded version of the RandomServer.
 * It spawns a new thread for each client connection allowing multiple concurrent clients.
 * The same protocol is followed as in RandomServer:
 * - "roll #"
 * - "flip"
 * - "goodbye"
 * - any other request results in "error" and termination of that client's connection.
 */
public class RandomThreadedServer {
    private static final int PORT = 12346;

    /**
     * Starts the RandomThreadedServer and continuously accepts client connections.
     * Each client connection is handled in a separate thread, allowing concurrent processing.
     *
     * @throws IOException if an I/O error occurs when waiting for a connection
     */
    public void start() throws IOException {
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("RandomThreadedServer started. Waiting for clients...");
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("New client connected.");
                Thread handlerThread = new Thread(new ClientHandler(clientSocket));
                handlerThread.start();
            }
        }
    }

    /**
     * The main method to start the threaded server.
     *
     * @param args command-line arguments
     * @throws IOException if an error occurs starting the server
     */
    public static void main(String[] args) throws IOException {
        RandomThreadedServer server = new RandomThreadedServer();
        server.start();
    }

    /**
     * Inner class for handling a single client connection in a dedicated thread.
     */
    private static class ClientHandler implements Runnable {
        private final Socket clientSocket;
        private final Random random = new Random();

        /**
         * Constructs a ClientHandler with a given client socket.
         *
         * @param clientSocket the client socket to be handled
         */
        public ClientHandler(Socket clientSocket) {
            this.clientSocket = clientSocket;
        }

        /**
         * The run method to process client requests in a loop.
         * Closes the connection upon receiving "goodbye" or an error.
         */
        @Override
        public void run() {
            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {

                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    String response = processRequest(inputLine);
                    out.println(response);
                    if ("bye".equals(response) || "error".equals(response)) {
                        break;
                    }
                }

            } catch (IOException e) {
                System.err.println("Client connection error: " + e.getMessage());
            } finally {
                try {
                    clientSocket.close();
                } catch (IOException ignored) {
                }
                System.out.println("Client disconnected.");
            }
        }

        /**
         * Processes a single client request according to the defined protocol.
         *
         * @param request the client request string
         * @return the server response string
         */
        private String processRequest(String request) {
            // Check for "goodbye"
            if ("goodbye".equalsIgnoreCase(request.trim())) {
                return "bye";
            }

            // Check for "flip"
            if ("flip".equalsIgnoreCase(request.trim())) {
                return random.nextBoolean() ? "heads" : "tails";
            }

            // Check for "roll #"
            if (request.toLowerCase().startsWith("roll")) {
                String[] parts = request.trim().split("\\s+");
                if (parts.length == 2) {
                    try {
                        int numberOfDice = Integer.parseInt(parts[1]);
                        if (numberOfDice > 0) {
                            int sum = 0;
                            for (int i = 0; i < numberOfDice; i++) {
                                sum += (random.nextInt(6) + 1);
                            }
                            return String.valueOf(sum);
                        }
                    } catch (NumberFormatException e) {
                        // fall through to error
                    }
                }
            }

            // Any other request is invalid
            return "error";
        }
    }
}


3.
/*
 * RandomClient.java
 * Name of the class: SWEN.601.01 - Software Construction
 * Name: Atharva Vaidya
 * Email: aav6986@g.rit.edu
 * ---------------------------------------------  Final Exam ---------------------------------------------
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

/**
 * The RandomClient class implements the client side of the protocol described for RandomServer.
 * It connects to the server, sends user-entered requests, and prints the server's responses.
 *
 * Example usage:
 * Run RandomServer separately, then run RandomClient.
 * Enter commands like:
 * - "roll 5" -> server returns sum of rolling 5 dice
 * - "flip"   -> server returns "heads" or "tails"
 * - "goodbye"-> server returns "bye" and disconnects
 *
 * Any invalid request returns "error" and disconnects the client.
 */
public class RandomClient {
    private static final String HOST = "localhost";
    private static final int PORT = 12345; // match the RandomServer's port

    /**
     * Starts the RandomClient, connects to the RandomServer, and allows the user to input commands.
     * The responses from the server are printed until the server disconnects.
     *
     * @throws IOException if an I/O error occurs when connecting or communicating with the server
     */
    public void start() throws IOException {
        try (Socket socket = new Socket(HOST, PORT);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
             Scanner scanner = new Scanner(System.in)) {

            System.out.println("Connected to RandomServer at " + HOST + ":" + PORT);
            System.out.println("Enter commands (e.g. 'roll 6', 'flip', 'goodbye'):");

            String userInput;
            while (true) {
                System.out.print("> ");
                if (!scanner.hasNextLine()) {
                    break;
                }
                userInput = scanner.nextLine();
                out.println(userInput);

                String serverResponse = in.readLine();
                if (serverResponse == null) {
                    System.out.println("Server disconnected.");
                    break;
                }
                System.out.println("Server: " + serverResponse);

                if ("bye".equals(serverResponse) || "error".equals(serverResponse)) {
                    System.out.println("Connection closed by server.");
                    break;
                }
            }
        }
    }

    /**
     * The main method to start the RandomClient.
     *
     * @param args command-line arguments
     * @throws IOException if an error occurs connecting to the server
     */
    public static void main(String[] args) throws IOException {
        RandomClient client = new RandomClient();
        client.start();
    }
}

quiz

Question 2 (1 point)
Number the steps in the development lifecycle so that they are in the correct order:

Pull the latest code from GitHub.
Add some new code.
Compile, run, and test your code.
Fix bugs until your tests pass.
Use git to commit your changes to your local repository.
Push your changes to GitHub.

Question 3 (1 point)
For each type, choose either "primitive" or "reference":

Object: Reference
short: Primitive
int[]: Reference
String: Reference
ArrayList: Reference
byte: Primitive
float: Primitive
Integer: Reference
char: Primitive
boolean: Primitive



Question 5 (1 point)
Check all of the true statements below:

A char is an integer.
The scope of a variable is from the line on which it is declared to the end of the body in which it is declared.
Conditionals are used to implement a branching flow of control.
When using a switch statement, any statements following the matching case will be executed, including statements in other cases, until a break statement.
The statements in the body of a while loop may be executed 0 or more times.
An array is passed into a function as a reference.
Java supports arrays with any number of dimensions (1, 2, or more).

Question 6 (1 point)
Given that a = false and b = true, check any expression that evaluates to true:

b && !a
b || !a
(a || b) && !(a && b)

Question 7 (1 point)
Match each term with the correct definition:

Overriding: Replacing a method in the parent class with a new implementation in the child.
Polymorphism: Allows an instance of a child class to be used in code where the parent is expected.
Test-Driven Development (TDD): A development process that involves writing tests first, and the code to make the test pass afterwards.
Unit Test: A class that comprises many small tests, each of which usually tests only a single method.
Refactoring: Used to safely modify your code, allowing you to rerun tests and ensure no previous functionality is broken.
Base Case: The part of a recursive function that determines when the work should stop.
Recursive Case: The part of a recursive function that does a unit of work and makes a recursive call.
Stack Overflow: Refers to exceeding the maximum number of stack frames allowed in the call stack.
In-Place Sort: A sort performed within the array itself by swapping values between indexes.
Natural Order: Given any two elements, determines which comes first in sorted order.

Question 8 (1 point)
File: SCR-20241212-hxhf.png
Check all of the true statements below:

If no access modifier is specified, a field or method is only visible to other classes in the same package.
Two objects of the same class can see and/or change each other's private fields.
The "new" keyword tells Java to find some memory and store something there, like a new array or an object.
When used to compare two variables, the == operator will compare the value stored in each variable's location in memory.
The string literal pool means that the behavior of the == operator is sometimes unpredictable when comparing strings.

Question 9 (1 point)
Select the correct complexity (average case unless stated otherwise):

Binary Search: O(log N)
Quicksort (worst case): O(N²)
Array List (access by index): O(1)
Array List (add to the end): O(1)
Linked List (add to the front): O(1)
Merge Sort (worst case): O(N log N)
Set (add a value): O(1)

Question 10 (1 point)
Match each term with the correct definition:

Hash Function: A one-way function that converts arbitrary data into a number.
Collision: Caused when two or more keys are mapped to the same index in a hash map.
Chaining: Uses a list to handle the event that two keys are placed into the same index in a hash map.
Open Addressing: Places the second key in the next empty index in the array when two keys are placed into the same index in a hash map.
Pre-Order Traversal: Visits the node first, then the left subtree, then the right subtree.
In-Order Traversal: Visits the left subtree, then the node, then the right subtree.
Post-Order Traversal: Visits the left subtree, then the right subtree, then the node.
Readers/Writers: Used to read/write character data to/from a data source (e.g., a file).
Input/Output Streams: Used to read/write binary data to/from a data source (e.g., a file).
Flushing: Forces buffered data to be written.

Question 12 (1 point)
File: SCR-20241212-iawx.png
Arrange the TDD steps so that they are in the correct order:

Fail: Write a failing test.
Pass: Write the minimal code to make the test pass.
Refactor.
Commit/Push.

Question 13 (1 point)
Check all of the true statements below:

Two objects that are equal according to their equals(Object) methods should always return the same hash code.
As the number of collisions in a hash map increases, the performance of the put and get operations approaches O(N).
Once determined, an object's hash code must never change.
A binary search tree is one where, given the value V of any node, all values in the left subtree are less than V, and all values in the right subtree are greater.
Question 15 (0.5 points)
Use Breadth First Search (BFS) to find the path from A to I. Assume neighbors are visited in alphabetical order:

A → B → C → D → H → I

Question 14 (1 point)
File: SCR-20241212-ibbi.png
Choose the sequence that would create the min heap with the following configuration:
Answer: 1, 2, 3, 4, 5, 6

Question 15 (0.5 points)
File: SCR-20241212-ibcx.png
Use breadth first search (BFS) to find the path from A to I. Assume that neighbors are visited in alphabetical order:
Answer: ABCDEFGHI

Question 16: Use Depth First Search (DFS)
File: SCR-20241212-ibif.png
Use Depth First Search (DFS) to find the path from A to I. Assume that neighbors are visited in alphabetical order:

ABFGECDHI
ABCDEFGHI
ABFJI
ABGEDHI
Answer: ABFGECDHI


Question 17 (1 point)
Check all of the true statements below:

Breadth First Search (BFS) will always find a path with the fewest possible edges.
Dijkstra's Algorithm will always find the shortest path in terms of weights.
A try must always be followed by at least one catch or exactly one finally.
A thread may be moved to the WAITING state if sleep, join, or wait are used.
A thread in the WAITING state can be interrupted.
At least two threads and two locks must be involved to create deadlock.


