1.
/*
 * RandomServer.java
 * Name of the class: SWEN.601.01 - Software Construction
 * Name: Atharva Vaidya
 * Email: aav6986@g.rit.edu
 * ---------------------------------------------  Final Exam ---------------------------------------------
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Random;

/**
 * The RandomServer class implements a simple server that listens for client requests
 * and responds according to a predefined protocol:
 * - "roll #" where # is a positive integer: roll the specified number of 6-sided dice and return the sum.
 * - "flip": flip a coin and return "heads" or "tails".
 * - "goodbye": respond with "bye" and disconnect.
 * - any other request: respond with "error" and disconnect.
 *
 * This server handles a single client connection at a time (sequential).
 */
public class RandomServer {
    private static final int PORT = 12345;
    private final Random random = new Random();

    /**
     * Starts the RandomServer and listens for a single client connection. Once connected,
     * it handles client requests sequentially until a disconnect condition occurs.
     *
     * @throws IOException if an I/O error occurs when waiting for a connection or reading/writing data
     */
    public void start() throws IOException {
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("RandomServer started. Waiting for client...");
            try (Socket clientSocket = serverSocket.accept();
                 BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {
                System.out.println("Client connected.");

                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    String response = processRequest(inputLine);
                    out.println(response);
                    if (response.equals("bye") || response.equals("error")) {
                        System.out.println("Client disconnected.");
                        break;
                    }
                }
            }
        }
    }

    /**
     * Processes a single client request according to the defined protocol.
     *
     * @param request the client request string
     * @return the server response string
     */
    private String processRequest(String request) {
        // Check for "goodbye"
        if ("goodbye".equalsIgnoreCase(request.trim())) {
            return "bye";
        }

        // Check for "flip"
        if ("flip".equalsIgnoreCase(request.trim())) {
            return random.nextBoolean() ? "heads" : "tails";
        }

        // Check for "roll #"
        if (request.toLowerCase().startsWith("roll")) {
            String[] parts = request.trim().split("\\s+");
            if (parts.length == 2) {
                try {
                    int numberOfDice = Integer.parseInt(parts[1]);
                    if (numberOfDice > 0) {
                        int sum = 0;
                        for (int i = 0; i < numberOfDice; i++) {
                            sum += (random.nextInt(6) + 1);
                        }
                        return String.valueOf(sum);
                    }
                } catch (NumberFormatException e) {
                    // fall through to error
                }
            }
        }

        // Any other request is invalid
        return "error";
    }

    /**
     * The main method to start the server.
     *
     * @param args command-line arguments
     * @throws IOException if an error occurs starting the server
     */
    public static void main(String[] args) throws IOException {
        RandomServer server = new RandomServer();
        server.start();
    }
}

2.
/*
 * RandomThreadedServer.java
 * Name of the class: SWEN.601.01 - Software Construction
 * Name: Atharva Vaidya
 * Email: aav6986@g.rit.edu
 * ---------------------------------------------  Final Exam ---------------------------------------------
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Random;

/**
 * The RandomThreadedServer class is a multi-threaded version of the RandomServer.
 * It spawns a new thread for each client connection allowing multiple concurrent clients.
 * The same protocol is followed as in RandomServer:
 * - "roll #"
 * - "flip"
 * - "goodbye"
 * - any other request results in "error" and termination of that client's connection.
 */
public class RandomThreadedServer {
    private static final int PORT = 12346;

    /**
     * Starts the RandomThreadedServer and continuously accepts client connections.
     * Each client connection is handled in a separate thread, allowing concurrent processing.
     *
     * @throws IOException if an I/O error occurs when waiting for a connection
     */
    public void start() throws IOException {
        try (ServerSocket serverSocket = new ServerSocket(PORT)) {
            System.out.println("RandomThreadedServer started. Waiting for clients...");
            while (true) {
                Socket clientSocket = serverSocket.accept();
                System.out.println("New client connected.");
                Thread handlerThread = new Thread(new ClientHandler(clientSocket));
                handlerThread.start();
            }
        }
    }

    /**
     * The main method to start the threaded server.
     *
     * @param args command-line arguments
     * @throws IOException if an error occurs starting the server
     */
    public static void main(String[] args) throws IOException {
        RandomThreadedServer server = new RandomThreadedServer();
        server.start();
    }

    /**
     * Inner class for handling a single client connection in a dedicated thread.
     */
    private static class ClientHandler implements Runnable {
        private final Socket clientSocket;
        private final Random random = new Random();

        /**
         * Constructs a ClientHandler with a given client socket.
         *
         * @param clientSocket the client socket to be handled
         */
        public ClientHandler(Socket clientSocket) {
            this.clientSocket = clientSocket;
        }

        /**
         * The run method to process client requests in a loop.
         * Closes the connection upon receiving "goodbye" or an error.
         */
        @Override
        public void run() {
            try (BufferedReader in = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                 PrintWriter out = new PrintWriter(clientSocket.getOutputStream(), true)) {

                String inputLine;
                while ((inputLine = in.readLine()) != null) {
                    String response = processRequest(inputLine);
                    out.println(response);
                    if ("bye".equals(response) || "error".equals(response)) {
                        break;
                    }
                }

            } catch (IOException e) {
                System.err.println("Client connection error: " + e.getMessage());
            } finally {
                try {
                    clientSocket.close();
                } catch (IOException ignored) {
                }
                System.out.println("Client disconnected.");
            }
        }

        /**
         * Processes a single client request according to the defined protocol.
         *
         * @param request the client request string
         * @return the server response string
         */
        private String processRequest(String request) {
            // Check for "goodbye"
            if ("goodbye".equalsIgnoreCase(request.trim())) {
                return "bye";
            }

            // Check for "flip"
            if ("flip".equalsIgnoreCase(request.trim())) {
                return random.nextBoolean() ? "heads" : "tails";
            }

            // Check for "roll #"
            if (request.toLowerCase().startsWith("roll")) {
                String[] parts = request.trim().split("\\s+");
                if (parts.length == 2) {
                    try {
                        int numberOfDice = Integer.parseInt(parts[1]);
                        if (numberOfDice > 0) {
                            int sum = 0;
                            for (int i = 0; i < numberOfDice; i++) {
                                sum += (random.nextInt(6) + 1);
                            }
                            return String.valueOf(sum);
                        }
                    } catch (NumberFormatException e) {
                        // fall through to error
                    }
                }
            }

            // Any other request is invalid
            return "error";
        }
    }
}


3.
/*
 * RandomClient.java
 * Name of the class: SWEN.601.01 - Software Construction
 * Name: Atharva Vaidya
 * Email: aav6986@g.rit.edu
 * ---------------------------------------------  Final Exam ---------------------------------------------
 */

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.net.Socket;
import java.util.Scanner;

/**
 * The RandomClient class implements the client side of the protocol described for RandomServer.
 * It connects to the server, sends user-entered requests, and prints the server's responses.
 *
 * Example usage:
 * Run RandomServer separately, then run RandomClient.
 * Enter commands like:
 * - "roll 5" -> server returns sum of rolling 5 dice
 * - "flip"   -> server returns "heads" or "tails"
 * - "goodbye"-> server returns "bye" and disconnects
 *
 * Any invalid request returns "error" and disconnects the client.
 */
public class RandomClient {
    private static final String HOST = "localhost";
    private static final int PORT = 12345; // match the RandomServer's port

    /**
     * Starts the RandomClient, connects to the RandomServer, and allows the user to input commands.
     * The responses from the server are printed until the server disconnects.
     *
     * @throws IOException if an I/O error occurs when connecting or communicating with the server
     */
    public void start() throws IOException {
        try (Socket socket = new Socket(HOST, PORT);
             PrintWriter out = new PrintWriter(socket.getOutputStream(), true);
             BufferedReader in = new BufferedReader(new InputStreamReader(socket.getInputStream()));
             Scanner scanner = new Scanner(System.in)) {

            System.out.println("Connected to RandomServer at " + HOST + ":" + PORT);
            System.out.println("Enter commands (e.g. 'roll 6', 'flip', 'goodbye'):");

            String userInput;
            while (true) {
                System.out.print("> ");
                if (!scanner.hasNextLine()) {
                    break;
                }
                userInput = scanner.nextLine();
                out.println(userInput);

                String serverResponse = in.readLine();
                if (serverResponse == null) {
                    System.out.println("Server disconnected.");
                    break;
                }
                System.out.println("Server: " + serverResponse);

                if ("bye".equals(serverResponse) || "error".equals(serverResponse)) {
                    System.out.println("Connection closed by server.");
                    break;
                }
            }
        }
    }

    /**
     * The main method to start the RandomClient.
     *
     * @param args command-line arguments
     * @throws IOException if an error occurs connecting to the server
     */
    public static void main(String[] args) throws IOException {
        RandomClient client = new RandomClient();
        client.start();
    }
}

quiz
1.

2.
The correct order of the steps in the development lifecycle is:

Pull the latest code from GitHub. (Ensure you have the most up-to-date version of the code before making changes.)
Add some new code. (Make your changes or additions to the codebase.)
Compile, run, and test your code. (Ensure your changes work as intended.)
Fix bugs until your tests pass. (Resolve any issues found during testing.)
Use git to commit your changes to your local repository. (Save your work locally with a meaningful commit message.)
Push your changes to GitHub. (Share your changes with others by pushing them to the remote repository.)







3.

Here are the correct classifications for each type:

Object: Reference
short: Primitive
int[]: Reference
String: Reference
ArrayList: Reference
byte: Primitive
float: Primitive
Integer: Reference
char: Primitive
boolean: Primitive

4.

Matching Definitions:
Variable: A name for an address in memory.
Variable Table: Stores identifiers, types, and addresses so that when an identifier is used, the value can be retrieved.
Memory: Organized as addresses into which the computer can store data and from which the computer can retrieve data.
Class: A blueprint or template that defines the state and behavior for a category of things.
Object: A unique, identifiable instance of a class that has its own copy of the state and behavior.
Field: A variable that belongs to an object.
Method: A function that belongs to an object.
Shallow Equality: Comparing two values using only identity (i.e. value or address stored in memory).
Deep Equality: Comparing the state of two objects, i.e. the value of the variables inside of the objects.
super: Used by a child class to refer to the state and behavior in its parent and to call a constructor on the parent.

5.

Based on the image content, here are the true statements:

A char is an integer: True

A char in Java is a 16-bit unsigned integer (numeric value) that represents a Unicode character.
The scope of a variable is from the line on which it is declared to the end of the body in which it is declared: True

This is the rule for variable scope in Java.
A variable must be initialized at the same time that it is declared, e.g., int x = 5;: False

Variables can be declared without being initialized, but they must be initialized before being used.
Conditionals are used to implement a branching flow of control: True

Statements like if, else if, and else implement branching logic.
When using a switch statement, any statements following the matching case will be executed, including statements in other cases, until a break statement: True

Without a break, the execution "falls through" to subsequent cases.
The statements in the body of a while loop may be executed 0 or more times: True

If the condition is false initially, the body of the loop won't execute at all.
The statements in the body of a loop or conditional must be enclosed in curly braces ({}) to avoid a compiler error: False

Single statements don't require curly braces, though it's a good practice to use them.
int[] x = new int[5]; creates an array large enough to store 6 integers at indexes 0 through 5: False

It creates an array large enough to store 5 integers, indexed from 0 to 4.
An array is passed into a function as a reference: True

Arrays in Java are reference types, so the reference to the array is passed, not a copy.
Java supports arrays with any number of dimensions (i.e., 1, 2, or more): True

Java supports multi-dimensional arrays.
